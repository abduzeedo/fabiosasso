<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="theme-color" content="#B5AFAC" />
    <meta name="viewport"content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <link rel="manifest" href="manifest.json" />
    <title>LETTRIX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Luckiest+Guy&family=Monda:wght@400..700&&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
      :root {
        --device-color: #B5AFAC;
        --board-columns: 6;
        --board-rows: 10;
        --bg-color: #ABB1AD;
        --bg-color-sec: #eeeeee;
        --text-color: #000000;
        --overlay-bg: #ABB1AD;
        --ts-1: #ABB1AD;
        --ts-2: #999;
        --ts-3: #888;
        --ts-4: #777;
        --ts-5: #666;
        --ts-6: #555;
        --ts-7: #444;
        --ts-8: #333;
        --ts-9: #302314;
      }

      body {
        user-select: none;
        -webkit-user-select: none;
        font-family: system-ui, sans-serif;
        touch-action: manipulation;
        overflow: hidden;
        background-color: #B5AFAC;
        color: var(--text-color);
        transition: background-color 0.3s ease, color 0.3s ease;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
      }
      .main-area{
        max-width:640px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        margin: 0 auto;
      }
      .game-wrapper {
        font-family: "Luckiest Guy", system-ui, sans-serif;
        width: calc(100% - 20px);
        max-width: 640px;
        height: calc(100% - 256px);
        margin: 0 10px 15px 10px;
        position: relative;
        overflow: hidden;
        background-color: var(--bg-color);
        border: 8px solid rgba(1, 1, 1, 1);
        border-radius: 12px;
      }
      .game-container {
        flex: 1;
        width: 100%;
        height: 100%;
        display: flex;
        position: relative;
        justify-content: center;
        align-items: center;
        /* Padding to account for toolbar (64) and target words (48) at top */
        padding-top: 10px;
        padding-bottom: 5px;
        
      }
      .game-board {
        position: relative;
        display: grid;
        grid-template-columns: repeat(var(--board-columns), 1fr);
        grid-template-rows: repeat(var(--board-rows), 1fr);
        width: min(360px, 95%);
        aspect-ratio: var(--board-columns) / var(--board-rows);
        height: calc(100% - 112px); /* 64 (toolbar) + 48 (target words) */
        overflow: hidden;
        border-right: 1px solid #808080;
  
        margin-top: 0;
        background-image: linear-gradient(
          to right,
          #808080 1px,
          transparent 1px
        );
        background-size: calc(100% / var(--board-columns)) 100%;
      }
      .block { 
        display: flex;
        align-items: center;
        align-content: center;
        justify-content: center;
        text-align: center;
        font-weight: 400;
        font-size: 32px;
        line-height: 1;
        color: var(--text-color);
        /* transition: all 0.2s ease-in-out; */
        /* border-right: 1px solid #909090;
        border-bottom: 1px solid #909090; */
        /* text-shadow: 
        0 1px 1px var(--ts-1), 
        0 2px 0 var(--ts-2),
        0 3px 0 var(--ts-3), 
        0 4px 0 var(--ts-4), 
        0 5px 0 var(--ts-5),
        0 6px 0 var(--ts-6), 
        0 7px 0 var(--ts-7), 
        0 8px 0 var(--ts-8); */
      }
      .forming-word {
        font-weight: 900;
        /* Animation handled by GSAP */
      }
      .game-overlay h2 span {
        display: inline-block;
      }
      #start-screen {
        background-color: var(--overlay-bg);
        color: var(--text-color);
      }
      .toolbar,
      .bottom-bar {
        position: absolute;
        left: 0;
        right: 0;
        z-index: 100;
        opacity: 0;
        pointer-events: none; /* Default to none until game starts */
        background-color: var(--bg-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .toolbar {
        top: 0;
        height: 64px;
        padding: 0 1rem;
        /* border-bottom: 2px solid rgba(128, 128, 128, 0.4); */
      }
      .bottom-bar {
        display: none;
      }
      .target-words-container {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 90;
        opacity: 0;
        height: 48px;
        line-height: 48px;
        text-align: center;
        background-color: var(--text-color);
        /* border-bottom: 1px solid rgba(128, 128, 128, 0.2); */
        color: var(--bg-color);
      }

      button.btn-3d {
        background: #000000;
        color: #DCD6D2;
        position: relative;
        box-shadow: 
        0 1px 0 var(--ts-1), 
        0 2px 0 var(--ts-2),
        0 4px 0 var(--ts-3), 
        0 8px 0 var(--ts-4);
        transition: all 0.1s ease;
      }
      .btn-3d:active {
        
        transform: translateY(2px);
        box-shadow: 0 1px 0 var(--ts-1), 0 2px 0 var(--ts-2);
      }
      .game-overlay {
        position: absolute; /* Absolute within wrapper */
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--overlay-bg);
        backdrop-filter: blur(5px);
        display: flex;
        flex-direction: column;
        justify-content: space-evenly;
        align-items: center;
        color: var(--text-color);
        z-index: 150; /* Above bars, below sheet */
      }
      .bottom-sheet {
        position: absolute; /* Absolute within wrapper */
        bottom: -100%;
        left: 0;
        right: 0;
        height: 60%;
        background-color: var(--overlay-bg);
        backdrop-filter: blur(15px);
        border-top: 2px solid rgba(128, 128, 128, 0.3);
        border-top-left-radius: 2rem;
        border-top-right-radius: 2rem;
        transition: bottom 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 200;
        padding-bottom: env(safe-area-inset-bottom);
      }
      .bottom-sheet.show {
        bottom: 0;
      }
      .toolbar {
        height: 64px;
        line-height: 64px;
      }
      .bottom-bar {
        display: none;
      }

      .target-words-container {
        padding: 0 0.5rem;
        height: 48px;
        line-height: 48px;
        text-align: center;

        border-bottom: 1px solid rgba(128, 128, 128, 0.2);
      }
      .target-word {
        display: inline-block;
        margin: 0 0.5rem;
        font-weight: 700;
        letter-spacing: 0.1em;
        font-size: 13px;
        transition: all 0.3s ease;
      }
      .target-word.found {
        text-decoration: line-through;
        opacity: 0.6;
        color: var(--bg-color);
      }
      /* Options Slider Styles */
      #speed-slider {
        width: 100%;
        margin: 20px 0;
        -webkit-appearance: none;
        appearance: none;
        height: 8px;
        background: #ddd;
        border-radius: 5px;
        outline: none;
      }
      #speed-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 24px;
        height: 24px;
        background: #8D004C;
        cursor: pointer;
        border-radius: 50%;
        border: 2px solid #620135;
      }
      .slider-labels {
        display: flex;
        justify-content: space-between;
        font-size: 14px;
        font-family: 'Monda', sans-serif;
        color: var(--text-color);
        margin-top: -10px;
      }

      .gamepad{
        width: 100%;
        height: 172px;
        padding: 0 10px;
        position: relative;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        font-family: 'Monda', sans-serif;
        margin-bottom: 20px;
      }
      .directional{
        width:164px;
        height: 172px;
        position: relative;
        
      }
      .options{
        text-align: center;
        text-shadow: 0 -0.5px 0 rgba(0, 0, 0, 0.90), 0 0.5px 0 rgba(255, 255, 255, 0.5);
        color: var(--device-color);
        font-weight: 700;
        font-size: 12px;
        text-transform: uppercase;
        width: 64px;
      height: 172px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
      }
      .actions{
        width:164px;
        height: 172px;
        display: flex;
        position: relative;
        flex-direction: row;
        justify-content: center;
        align-items: center;
      }
      .bevel{
        stroke-width: 1px;
        stroke: #000;
        box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.50), 1px -1px 0 1px rgba(0, 0, 0, 0.50) inset, -1px 1px 0 1px rgba(255, 255, 255, 0.50) inset;
      
      }
      .bevel:hover{
        stroke: #620135;
        box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.50), 1px -1px 0 1px rgba(0, 0, 0, 0.50) inset, -1px 1px 0 1px rgba(255, 255, 255, 0.50) inset;
        
      }
      .action-button{
        width: 64px;
        height: 64px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 32px;
        border-radius: 50%;
        background: #8D004C;
        text-shadow: 0 -0.5px 0 rgba(0, 0, 0, 0.90), 0 0.5px 0 rgba(255, 255, 255, 0.3);
        color: #620135;
      }
      .select-button{
        width: 64px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        border-radius: 10px;
        background: var(--device-color);
        margin-bottom: 4px;
      }
    #A-button{
      position: absolute;
      bottom: 24px;
      left: 32;
    }
    #B-button{
      position: absolute;
      top: 24px;
     right: 0;
    }
    .directional-button{
      height: 64px;
      width: 64px;
      border-radius: 50%;
      position: absolute;
      font-size: 12px;
      font-weight: bolder;
      text-shadow: 0 -0.5px 0 rgba(0, 0, 0, 0.90), 0 0.5px 0 rgba(255, 255, 255, 0.3);
       background: #404040;
       color: #2f2f2f;
    }
    #up-button{
      top: 0;
      left: 50%;
      transform: translateX(-50%);
    }
    #down-button{
      bottom: 0px;
      left: 50%;
      transform: translateX(-50%);
    }
    #left-button{
      top: calc(50%);
      transform: translateY(-50%);
      left: 0;
    }
    #right-button{
      top: calc(50%);
      transform: translateY(-50%);
      right: 0;
    }
    .logo{
      width: 100%;
      padding: 0 10px;
      position: relative;
      bottom: 0;
      height: 24px;
    }
    .line{
      height: 3px;
      box-shadow: 0 -1px 0 rgba(0, 0, 0, 0.5);
      background-color: #a09a97;
      margin-bottom: 3px;
    }
    .logo-text{
      position: absolute;
      bottom: 0;
      right: 40px;
      text-align: center;
      font-size: 12px;
      font-weight: bolder;
      text-shadow: 0 -0.5px 0 rgba(0, 0, 0, 0.90), 0 0.5px 0 rgba(255, 255, 255, 0.5);
      color: var(--device-color);
      height: 25px;
      background: var(--device-color);
      padding: 0 10px
    }
    .slider-labels{
        font-family: "Luckiest Guy", system-ui, sans-serif;
    }

    </style>
  </head>
  <body class="flex flex-col h-screen">
    <div class="main-area flex-col w-full h-full">
    <div class="game-wrapper">
      <!-- Toolbar -->
      <div
        class="toolbar w-full p-4 flex justify-between items-center"
      >
        <h1 class="text-2xl font-bold tracking-widest">LETTRIX</h1>
        <div class="flex items-center gap-4">
          <div class="text-center">
            <div class="text-sm text-gray-600">LEVEL</div>
            <div id="level" class="text-xl font-bold">1</div>
          </div>
          <div class="text-center">
            <div class="text-sm text-gray-600">SCORE</div>
            <div id="score" class="text-xl font-bold">0</div>
          </div>
        </div>
      </div>

      <!-- Target Words -->
      <div id="target-words-container" class="target-words-container">
        <!-- Target words will be injected here -->
      </div>

      <!-- Game Area -->
      <div id="game-area" class="game-container relative">
        <div id="game-board" class="game-board"></div>
        <div id="pause-screen" class="game-overlay hidden">
          <h2 class="text-5xl font-bold mb-8">
            <span>P</span><span>A</span><span>U</span><span>S</span><span>E</span
            ><span>D</span>
          </h2>
          <div class="flex flex-col gap-6 items-center">
            <button
              id="resume-button"
              class="btn-3d bg-black text-white dark:bg-white dark:text-black font-bold py-3 px-8 rounded-lg text-lg min-w-[160px]"
            >
              Resume
            </button>
            <button
              id="pause-words-button"
              class="btn-3d bg-black text-white dark:bg-white dark:text-black font-bold py-3 px-8 rounded-lg text-lg min-w-[160px]"
            >
              Words
            </button>
            <button
              id="pause-options-button"
              class="btn-3d bg-black text-white dark:bg-white dark:text-black font-bold py-3 px-8 rounded-lg text-lg min-w-[160px]"
            >
              Options
            </button>
            <button
              id="quit-button"
              class="btn-3d bg-red-600 text-white font-bold py-3 px-8 rounded-lg text-lg min-w-[160px]"
            >
              Quit
            </button>
          </div>
        </div>
        <div id="game-over-screen" class="game-overlay hidden">
          <h2 id="game-over-title" class="text-4xl font-bold mb-4">Game Over</h2>
          <p class="text-xl mb-6">Final Score: <span id="final-score">0</span></p>
          <button
            id="restart-button"
            class="btn-3d bg-black text-white dark:bg-white dark:text-black font-bold py-3 px-6 rounded-lg text-lg"
          >
            Play Again
          </button>
        </div>
        <div id="start-screen" class="game-overlay">
          <h2 class="text-5xl font-bold mb-4 tracking-widest">
            <span>L</span><span>E</span><span>T</span><span>T</span><span>R</span
            ><span>I</span><span>X</span>
          </h2>
          <div id="start-instructions" class="mb-6 text-center max-w-sm" style="padding: 0 20px; opacity: 0.5;">
            <p class="text-lg mb-2">Get your word game on!</p>
            <p class="text-lg mb-2">Use the gamepad to slide letters and the buttons to swap them.</p>
            <p class="text-lg">Letâ€™s see those word-making skills!</p>
          </div>
          <button
            id="start-button"
            class="btn-3d bg-black text-white dark:bg-white dark:text-black font-bold py-3 px-6 rounded-lg text-lg opacity-0"
          >
            Start Game
          </button> 
          <div id="support-creator" class="mt-8 text-center opacity-0" style="margin-top: 48px;">
          <h3>Support the creator</h3>
          <p><a href="https://abdz.gumroad.com/coffee" target="_blank" class="underline">Buy me a coffee</a></p>
          </div>
        </div>
      </div>


      <!-- Words Bottom Sheet -->
      <div id="words-sheet" class="bottom-sheet p-4">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-2xl font-bold">Collected Words</h2>
          <button id="close-words-button" class="font-bold text-2xl">
            &times;
          </button>
        </div>
        <ul id="found-words-list" class="h-full overflow-y-auto pb-12">
          <!-- Found words will be added here -->
        </ul>
      </div>

      <!-- Options Bottom Sheet -->
      <div id="options-sheet" class="bottom-sheet p-4">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-2xl font-bold">Game Options</h2>
          <button id="close-options-button" class="font-bold text-2xl">
            &times;
          </button>
        </div>
        <div class="mt-8">
          <label class="text-lg font-bold mb-2 text-left">Drop Speed</label>
           <p class="mt-4 text-sm text-gray-500 italic text-left">Adjust how fast the letters fall. Changes take effect on next piece or resume.</p>
          <input type="range" id="speed-slider" min="500" max="5000" step="100" value="2000">
          <div class="slider-labels">
            <span class="text-left text-sm font-bold">Hard (0.5s)</span>
            <span class="text-right text-sm font-bold">Easy (5s)</span>
          </div>
         
        </div>
      </div>
    </div>

    <div class="logo">
      <div class="lines"> 
        <div class="line"></div>
        <div class="line"></div>
        <div class="line"></div>
      </div>
      <div class="logo-text">ABDZ.DO MINI GAMES</div>
    </div> 
    <div class="gamepad">

      <div class="directional">
        <button id="up-button" class="bevel directional-button">
        UP
      </button>
      <button id="down-button" class="bevel directional-button">
        DOWN
      </button>
      <button id="left-button" class="bevel directional-button">
        LEFT
      </button>
      <button id="right-button" class="bevel directional-button">
        RIGHT
      </button>
      </div>
      <div class="options">
        <button id="select-button" class="bevel select-button"></button>
        <span>Options</span>
      </div>
     <div class="actions">
      <button id="A-button" class="bevel action-button">
        A
      </button>
      <button id="B-button" class="bevel action-button" >
        B
      </button>
     </div>
    </div>
    </div>

    <script>
      // DOM Elements
      const boardElement = document.getElementById("game-board");
      const gameAreaElement = document.getElementById("game-area");
      const scoreElement = document.getElementById("score");
      const levelElement = document.getElementById("level");
      const gameOverScreen = document.getElementById("game-over-screen");
      const startScreen = document.getElementById("start-screen");
      const pauseScreen = document.getElementById("pause-screen");
      const finalScoreElement = document.getElementById("final-score");
      const startButton = document.getElementById("start-button");
      const restartButton = document.getElementById("restart-button");
      const pauseButton = document.getElementById("pause-button");
      const resumeButton = document.getElementById("resume-button");
      const quitButton = document.getElementById("quit-button");
      const wordsSheet = document.getElementById("words-sheet");
      const optionsSheet = document.getElementById("options-sheet");
      const closeWordsButton = document.getElementById("close-words-button");
      const closeOptionsButton = document.getElementById("close-options-button");
      const foundWordsListElement = document.getElementById("found-words-list");
      const speedSlider = document.getElementById("speed-slider");
      const targetWordsContainer = document.getElementById(
        "target-words-container"
      );
      const toolbar = document.querySelector(".toolbar");
      const bottomBar = document.querySelector(".bottom-bar");

      // Game Constants
      const BOARD_WIDTH = 6;
      const BOARD_HEIGHT = 10;
      let INITIAL_DROP_SPEED = 2000; // Base speed in milliseconds
      const SPEED_INCREMENT_PER_LEVEL = 100; // Amount to speed up per level



      // Sync CSS variables with constants
      document.documentElement.style.setProperty(
        "--board-columns",
        BOARD_WIDTH
      );
      document.documentElement.style.setProperty("--board-rows", BOARD_HEIGHT);
      const ALL_VALID_WORDS = [
        "ACCEPT",
        "ADAPT",
        "ADORE",
        "AGILE",
        "ALIGN",
        "ALIVE",
        "ANGEL",
        "AWARE",
        "AWAKE",
        "BEAUTY",
        "BLISS",
        "BLOOM",
        "BRAVE",
        "BRIGHT",
        "CALM",
        "CARE",
        "CHARM",
        "CLEAN",
        "CLEAR",
        "DANCE",
        "DREAM",
        "EAGER",
        "ENERGY",
        "ENJOY",
        "FAITH",
        "FAMILY",
        "FOCUS",
        "FRIEND",
        "GENTLE",
        "GIVEN",
        "GRACE",
        "GREAT",
        "GREEN",
        "GROWTH",
        "GUIDE",
        "HAPPY",
        "HEAL",
        "HEALTH",
        "HEART",
        "HOPE",
        "HUMBLE",
        "JOY",
        "JOYFUL",
        "KIND",
        "LAUGH",
        "LEARN",
        "LIGHT",
        "LOVE",
        "LOYAL",
        "LUCKY",
        "MAGIC",
        "NATURE",
        "NOBLE",
        "PEACE",
        "POWER",
        "PRIDE",
        "PROUD",
        "PURE",
        "READY",
        "RELAX",
        "RENEW",
        "REVIVE",
        "SACRED",
        "SAFE",
        "SERENE",
        "SHINE",
        "SMILE",
        "SPARK",
        "SPIRIT",
        "SPRING",
        "STRONG",
        "SWEET",
        "THANK",
        "THRIVE",
        "TRUST",
        "TRUTH",
        "UNITY",
        "UPLIFT",
        "VALUE",
        "VIGOR",
        "VITAL",
        "WARMTH",
        "WISDOM",
        "WONDER",
        "WORTHY",
        "ZEN",
      ];

      // Game State
      let board = [];
      let score = 0;
      let level = 1;
      let isGameOver = true;
      let isPaused = false;
      let gameLoopInterval;
      let currentPiece;
      let wordFindCounts = {};
      let targetWords = [];
      let availableLetters = "";
      let availableLetterIndex = 0;
      let currentPieceLetterIndex = 0;
      let wordsFoundThisLevel = 0;
      let isAdvancingLevel = false;
      let gameDropSpeed = INITIAL_DROP_SPEED; // Current drop speed variable

      // Swipe Controls State
      let touchStartX = 0;
      let touchStartY = 0;
      let touchMoveX = 0;
      let touchMoveY = 0;
      let isTouchMoving = false;

      /**
       * Updates the drop speed based on initial setting and current level.
       */
      function updateDropSpeed() {
        const levelBonus = (level - 1) * SPEED_INCREMENT_PER_LEVEL;
        gameDropSpeed = Math.max(200, INITIAL_DROP_SPEED - levelBonus);

        if (!isPaused && !isGameOver) {
          if (gameLoopInterval !== null) {
            clearInterval(gameLoopInterval);
          }
          gameLoopInterval = setInterval(gameLoop, gameDropSpeed);
        }
      }

      /**
       * Prepares a fresh game state, resetting level and words.
       */
      function setupNewGame() {
        level = 1;
        updateDropSpeed();
        wordsFoundThisLevel = 0;
        isAdvancingLevel = false;
        levelElement.textContent = level;
        setupLevelWords();
      }


      /**
       * Randomly selects 5 target words for the current level and creates a letter pool.
       */
      function setupLevelWords() {
        // Select 5 random words for current level
        targetWords = [];
        const wordsCopy = [...ALL_VALID_WORDS];
        for (let i = 0; i < 5; i++) {
          const randomIndex = Math.floor(Math.random() * wordsCopy.length);
          targetWords.push(wordsCopy.splice(randomIndex, 1)[0]);
        }

        // Display target words
        targetWordsContainer.innerHTML = "";
        targetWords.forEach((word) => {
          const span = document.createElement("span");
          span.textContent = word;
          span.className = "target-word";
          targetWordsContainer.appendChild(span);
        });

        // Create a pool of available letters from these words
        availableLetters = targetWords.join("");
        availableLetterIndex = 0;
        currentPieceLetterIndex = 0;
        wordsFoundThisLevel = 0;
      }

      /**
       * Advances the game to the next level, increasing difficulty and clearing some space on the board.
       */
      function advanceLevel() {
        level++;
        levelElement.textContent = level;

        // Increase speed slightly with each level
        updateDropSpeed();

        // Remove the top row as a reward for completing the level

        removeTopRow();

        // Setup new words for next level
        setupLevelWords();

        // Reset the level advancement flag
        isAdvancingLevel = false;

        // Show level up message
        console.log(`Level ${level} reached! Current Speed: ${gameDropSpeed}ms`);

        // Spawn new piece after level transition is complete
        spawnPiece();
      }

      /**
       * Removes the top row of the board and shifts others up.
       */
      function removeTopRow() {
        // Shift all rows up by one position (removing the top row)
        for (let y = 0; y < BOARD_HEIGHT - 1; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            board[y][x] = board[y + 1][x];
          }
        }

        // Clear the bottom row
        for (let x = 0; x < BOARD_WIDTH; x++) {
          board[0][x] = null;
        }

        // Redraw the board
        draw();
      }

      /**
       * Calculates points for a found word based on its length.
       * @param {string} word
       * @returns {number}
       */
      function calculateScore(word) {
        if (word.length < 3) return 0;
        let basePoints = 5;
        let multiplier = 1.2;
        let wordScore = basePoints * Math.pow(multiplier, word.length - 3);
        return Math.round(wordScore);
      }

      /**
       * Updates game score, display, and checks for level advancement.
       * @param {string} word
       */
      function updateScore(word) {
        wordFindCounts[word] = (wordFindCounts[word] || 0) + 1;
        let points = calculateScore(word);
        if (wordFindCounts[word] > 1) {
          points = Math.round(points / 2);
        }

        score += points;
        scoreElement.textContent = score;

        // Mark word as found in target words display
        const targetWordElements =
          targetWordsContainer.querySelectorAll(".target-word");
        targetWordElements.forEach((element) => {
          if (element.textContent === word) {
            element.classList.add("found");
          }
        });

        const li = document.createElement("li");
        li.className = "text-lg p-2 border-b border-gray-300";
        li.textContent = `${word} (+${points})`;
        foundWordsListElement.prepend(li);

        // Check if this is a new word found this level
        if (targetWords.includes(word)) {
          wordsFoundThisLevel++;

          // Check if we've found all 5 words for this level
          if (wordsFoundThisLevel >= 5 && !isAdvancingLevel) {
            isAdvancingLevel = true;
          }
        }
      }

      /**
       * Initializes the logical game board as a 2D array.
       */
      function createBoard() {
        board = Array.from({ length: BOARD_HEIGHT }, () =>
          Array(BOARD_WIDTH).fill(null)
        );
      }

      /**
       * Spawns a new letter piece at the top of the board.
       * Ends game if spawn position is blocked.
       */
      function spawnPiece() {
        // Get random letter from available letters
        const letter =
          availableLetters[Math.floor(Math.random() * availableLetters.length)];

        currentPiece = {
          x: Math.floor(BOARD_WIDTH / 2),
          y: 0,
          letter: letter,
        };

        // Reset the letter cycling index for this new piece
        currentPieceLetterIndex = 0;

        if (board[currentPiece.y][currentPiece.x]) {
          isGameOver = true;
          clearInterval(gameLoopInterval);
          gameOverScreen.classList.remove("hidden");
          finalScoreElement.textContent = score;

          // Wrap title in spans
          const title = document.getElementById("game-over-title");
          const text = title.textContent.trim();
          title.innerHTML = text
            .split("")
            .map((char) => `<span>${char === " " ? "&nbsp;" : char}</span>`)
            .join("");

          // Animate game over screen
          const tl = gsap.timeline();

          gsap.killTweensOf(
            "#game-over-screen h2 span, #game-over-screen p, #restart-button"
          );

          tl.fromTo(
            "#game-over-screen h2 span",
            { y: -150, opacity: 0 },
            {
              y: 0,
              opacity: 1,
              duration: 0.6,
              stagger: {
                amount: 0.4,
                from: "random",
              },
              ease: "back.out(1.7)",
            }
          );

          tl.fromTo(
            "#game-over-screen p, #restart-button",
            { opacity: 0, y: 20 },
            {
              opacity: 1,
              y: 0,
              duration: 0.5,
              stagger: 0.1,
              ease: "power2.out",
            },
            "-=0.2"
          );
        }
      }

      /**
       * Renders the current state of the board and active piece to the DOM.
       */
      function draw() {
        if (isPaused) return;

        // Use a more stable drawing approach to preserve GSAP animations
        const children = Array.from(boardElement.children);
        const totalBlocks = BOARD_HEIGHT * BOARD_WIDTH;

        if (children.length !== totalBlocks) {
          boardElement.innerHTML = "";
          for (let i = 0; i < totalBlocks; i++) {
            const block = document.createElement("div");
            block.classList.add("block");
            boardElement.appendChild(block);
          }
        }

        for (let y = 0; y < BOARD_HEIGHT; y++) {
          for (let x = 0; x < BOARD_WIDTH; x++) {
            const index = y * BOARD_WIDTH + x;
            const block = boardElement.children[index];
            const cell = board[y][x];

            if (cell) {
              if (block.textContent !== cell.letter) {
                block.textContent = cell.letter;
              }
              if (cell.isForming) block.classList.add("forming-word");
              else block.classList.remove("forming-word");

              if (cell.isClearing) block.classList.add("clearing");
              else block.classList.remove("clearing");

              // Fix: Force visibility for any block that has a letter and isn't actively animating in a word sequence
              if (!cell.isForming && !cell.isClearing) {
                gsap.set(block, { scale: 1, opacity: 1, rotationY: 0, y: 0 });
              }
            } else {
              // Reset empty blocks, but spare the current active piece block to allow cycling animations to play
              const isCurrentPieceBlock =
                currentPiece && x === currentPiece.x && y === currentPiece.y;

              block.textContent = "";
              block.classList.remove("forming-word", "clearing");

              if (!isCurrentPieceBlock) {
                gsap.set(block, { scale: 1, opacity: 1, rotationY: 0, y: 0 });
              }
            }
          }
        }

        if (currentPiece && !isGameOver) {
          const index = currentPiece.y * BOARD_WIDTH + currentPiece.x;
          const blockElement = boardElement.children[index];
          if (
            blockElement &&
            blockElement.textContent !== currentPiece.letter
          ) {
            blockElement.textContent = currentPiece.letter;
          }
        }
      }

      /**
       * Attempts to move the current piece by a given delta.
       * @param {number} dx - Horizontal change
       * @param {number} dy - Vertical change
       * @returns {boolean} - Whether the move was successful
       */
      function movePiece(dx, dy) {
        if (isGameOver || isPaused) return false;
        const newX = currentPiece.x + dx;
        const newY = currentPiece.y + dy;

        if (isValidMove(newX, newY)) {
          currentPiece.x = newX;
          currentPiece.y = newY;
          return true;
        }
        return false;
      }

      /**
       * Checks if a position is within bounds and not occupied.
       * @param {number} x
       * @param {number} y
       * @returns {boolean}
       */
      function isValidMove(x, y) {
        return x >= 0 && x < BOARD_WIDTH && y < BOARD_HEIGHT && !board[y][x];
      }

      /**
       * Drops the piece to the lowest possible position immediately.
       */
      function dropPiece() {
        while (movePiece(0, 1)) {
          /* continue dropping */
        }
        lockPiece();
      }

      /**
       * Locks the current piece into the board and triggers word checking.
       */
      function lockPiece() {
        const x = currentPiece.x;
        const y = currentPiece.y;
        board[y][x] = { letter: currentPiece.letter };

        const index = y * BOARD_WIDTH + x;
        const blockElement = boardElement.children[index];
        if (blockElement) {
          gsap.from(blockElement, {
            y: -20,
            duration: 0.4,
            ease: "bounce.out",
          });
        }

        checkForWords();
        
        // Delay spawning new piece if we are advancing level to avoid race conditions
        if (!isAdvancingLevel) {
          spawnPiece();
        }
      }

      /**
       * Scans the board for any of the target words in rows or columns.
       */
      function checkForWords() {
        let wordsFound = false;
        let coordsToClear = [];

        const checkDirection = (getString, getCoords) => {
          for (
            let i = 0;
            i < (getString === getRowString ? BOARD_HEIGHT : BOARD_WIDTH);
            i++
          ) {
            let line = getString(i);
            targetWords.forEach((word) => {
              let index = -1;
              while ((index = line.indexOf(word, index + 1)) !== -1) {
                wordsFound = true;
                updateScore(word);
                for (let k = 0; k < word.length; k++) {
                  let { x, y } = getCoords(i, index + k);
                  coordsToClear.push({ x, y });
                }
              }
            });
          }
        };

        const getRowString = (y) =>
          board[y].map((cell) => (cell ? cell.letter : " ")).join("");
        const getColString = (x) =>
          board.map((row) => (row[x] ? row[x].letter : " ")).join("");
        const getRowCoords = (y, x) => ({ x, y });
        const getColCoords = (x, y) => ({ x, y });

        checkDirection(getRowString, getRowCoords);
        checkDirection(getColString, getColCoords);

        if (wordsFound) {
          animateAndClearWords(coordsToClear);
        }
      }

      /**
       * Animates the clearance of found words and then removes them.
       * @param {Array<{x:number, y:number}>} coords
       */
      function animateAndClearWords(coords) {
        const elements = coords.map(({ x, y }) => {
          const index = y * BOARD_WIDTH + x;
          return boardElement.children[index];
        });

        // Bubble animation: Staggered grow and disappear
        gsap.to(elements, {
          scale: 2.5,
          duration: 0.3,
          stagger: 0.1,
          ease: "bounce.out",
          onStart: () => {
            coords.forEach(({ x, y }) => {
              if (board[y][x]) board[y][x].isForming = true;
            });
          },
        });

        gsap.to(elements, {
          scale: 0,
          opacity: 0,
          duration: 0.3,
          delay: 0.4,
          stagger: 0.1,
          ease: "power2.in",
          onComplete: () => {
            // Reset state of elements before draw() ensures they aren't stuck at 0
            gsap.set(elements, { scale: 1, opacity: 1 });
            clearAndCollapse(coords);
            draw();

            if (isAdvancingLevel) {
              advanceLevel();
            }
          },
        });
      }

      /**
       * Physically removes word cells from the board and collapses higher cells down.
       * @param {Array<{x:number, y:number}>} coords
       */
      function clearAndCollapse(coords) {
        const uniqueCoords = [
          ...new Set(coords.map((c) => `${c.x},${c.y}`)),
        ].map((s) => {
          const [x, y] = s.split(",");
          return { x: parseInt(x), y: parseInt(y) };
        });

        uniqueCoords.forEach(({ x, y }) => (board[y][x] = null));

        for (let x = 0; x < BOARD_WIDTH; x++) {
          let emptyRow = BOARD_HEIGHT - 1;
          for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
            if (board[y][x]) {
              [board[emptyRow][x], board[y][x]] = [
                board[y][x],
                board[emptyRow][x],
              ];
              emptyRow--;
            }
          }
        }
      }

      /**
       * Main game loop function. Moves current piece down or locks it.
       */
      function gameLoop() {
        if (isPaused || isGameOver) return;
        if (!movePiece(0, 1)) {
          lockPiece();
        }
        draw();
      }

      /**
       * Toggles the game's paused state and updates the UI.
       */
      function togglePause() {
        isPaused = !isPaused;
        pauseScreen.classList.toggle("hidden");
        if (isPaused) {
          clearInterval(gameLoopInterval);
          gameLoopInterval = null;
          // Reset and kill any pending animations on these elements
          gsap.killTweensOf("#pause-screen h2 span, #pause-screen .btn-3d");

          // Animate pause screen text
          gsap.fromTo(
            "#pause-screen h2 span",
            { y: -250, opacity: 0 },
            {
              y: 0,
              opacity: 1,
              duration: 0.5,
              stagger: {
                amount: 0.3,
                from: "random",
              },
              ease: "back.out(1.7)",
            }
          );
          gsap.fromTo(
            "#pause-screen .btn-3d",
            { scale: 0.1, opacity: 0 },
            {
              scale: 1,
              opacity: 1,
              duration: 0.5,
              delay: 0.3, // Slightly less delay for better feel
              stagger: 0.1,
              ease: "elastic.out(2, 0.8)",
            }
          );
        } else {
          gameLoopInterval = setInterval(gameLoop, gameDropSpeed);
        }
      }

      /**
       * Cycles the letter of the current piece through the available pool.
       * @param {number} direction - 1 for next, -1 for previous
       */
      function cycleLetter(direction = 1) {
        if (isGameOver || isPaused || !currentPiece) return;

        const index = currentPiece.y * BOARD_WIDTH + currentPiece.x;
        const blockElement = boardElement.children[index];

        if (blockElement) {
          const tl = gsap.timeline();

          // Pop out
          tl.to(blockElement, {
            scale: 0.5,
            opacity: 0,
            duration: 0.05,
            ease: "power2.in",
            onComplete: () => {
              // Cycle through all available letters for this piece
              currentPieceLetterIndex =
                (currentPieceLetterIndex + direction + availableLetters.length) %
                availableLetters.length;
              currentPiece.letter = availableLetters[currentPieceLetterIndex];
              draw(); // Update text content
            },
          });

          // Pop in
          tl.to(blockElement, {
            scale: 1,
            opacity: 1,
            duration: 0.15,
            ease: "back.out(2)",
          });
        } else {
          // Fallback if no block element found
          currentPieceLetterIndex =
            (currentPieceLetterIndex + direction + availableLetters.length) %
            availableLetters.length;
          currentPiece.letter = availableLetters[currentPieceLetterIndex];
          draw();
        }
      }

      /**
       * Instantly drops the piece to the bottom.
       */
      function hardDrop() {
        if (isGameOver || isPaused || !currentPiece) return;
        while (movePiece(0, 1)) {
          /* continue dropping */
        }
        lockPiece();
        draw();
      }


      /**
       * Resets word display.
       */
      function redrawTargetWords() {
        targetWordsContainer.innerHTML = "";
        targetWords.forEach((word) => {
          const span = document.createElement("span");
          span.textContent = word;
          span.className = "target-word";
          targetWordsContainer.appendChild(span);
        });
      }

      /**
       * Exits the current game and returns to the start screen.
       */
      function quitGame() {
        clearInterval(gameLoopInterval);
        gameLoopInterval = null;
        isPaused = false;
        isGameOver = false;

        // Hide all screens first
        pauseScreen.classList.add("hidden");
        gameOverScreen.classList.add("hidden");

        // Hide game UI
        const uiBars = [toolbar, targetWordsContainer];
        gsap.killTweensOf(uiBars);
        gsap.to(uiBars, {
          opacity: 0,
          duration: 0.3,
          onComplete: () => {
            uiBars.forEach((bar) => (bar.style.pointerEvents = "none"));
          },
        });


        // Reset board for a clean look behind overlay
        board = Array.from({ length: BOARD_HEIGHT }, () =>
          Array(BOARD_WIDTH).fill(null)
        );
        draw();

        // Reveal start screen
        startScreen.classList.remove("hidden");

        // Reset and run intro animation
        initStartScreen();
      }

      /**
       * Starts the game from the beginning.
       */
      function startGame() {
        isGameOver = false;
        isPaused = false;
        score = 0;
        wordFindCounts = {};
        scoreElement.textContent = "0";
        foundWordsListElement.innerHTML = "";
        gameOverScreen.classList.add("hidden");
        startScreen.classList.add("hidden");
        pauseScreen.classList.add("hidden");

        // Reveal game UI with robust fromTo
        const uiBars = [toolbar, targetWordsContainer];
        gsap.killTweensOf(uiBars);

        gsap.set(uiBars, { pointerEvents: "auto" });
        gsap.fromTo(
          uiBars,
          { opacity: 0, y: (i) => (i === 0 ? -50 : 0) },
          {
            opacity: 1,
            y: 0,
            duration: 0.5,
            stagger: 0.1,
            ease: "power2.out",
          }
        );


        setupNewGame();
        createBoard();
        spawnPiece();
        draw();
        // Removed redundant setInterval: updateDropSpeed (via setupNewGame) already starts it.
      }

      // Start Screen Animation Sequence
      function initStartScreen() {
        // Reset instructions opacity for clean fade-in
        gsap.set("#start-instructions", { opacity: 1 });
        gsap.set("#start-instructions p", { opacity: 0 });
        gsap.set("#support-creator", { opacity: 0 });

        const tl = gsap.timeline();

        // 1. Lettrix Title (random letter animation)
        tl.fromTo(
          "#start-screen h2 span",
          { y: -100, opacity: 0 },
          {
            y: 0,
            opacity: 1,
            duration: 0.6,
            stagger: {
              amount: 0.4,
              from: "random",
            },
            ease: "back.out(1.7)",
          }
        );

        // 2. Paragraph by paragraph fade-in
        tl.fromTo(
          "#start-instructions p",
          { opacity: 0, y: 10 },
          {
            opacity: 0.8,
            y: 0,
            duration: 0.8,
            stagger: 0.4,
            ease: "power2.out",
          },
          "+=0.2"
        );

        // 3. Start Button
        tl.fromTo(
          "#start-button",
          { opacity: 0, scale: 0.1 },
          {
            opacity: 1,
            scale: 1,
            duration: 0.6,
            ease: "elastic.out(2, 0.8)",
          },
          "-=0.2"
        );

        // 4. Support Creator
        tl.fromTo(
          "#support-creator",
          { opacity: 0, y: 10 },
          {
            opacity: 1,
            y: 0,
            duration: 0.8,
            ease: "power2.out",
          },
          "-=0.2"
        );
      }

      // Event Listeners
      window.addEventListener("load", initStartScreen);

      document.addEventListener("keydown", (e) => {
        if (isGameOver || isPaused) return;
        if (e.key === "ArrowLeft") movePiece(-1, 0);
        if (e.key === "ArrowRight") movePiece(1, 0);
        if (e.key === "ArrowDown") dropPiece();
        if (e.key === " ") {
          e.preventDefault();
          cycleLetter();
        }
        draw();
      });

      // Swipe Controls
      // Swipe Controls
      gameAreaElement.addEventListener(
        "touchstart",
        (e) => {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchMoveX = touchStartX;
          touchMoveY = touchStartY;
          isTouchMoving = false;
        },
        { passive: false }
      );

      gameAreaElement.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault(); // Prevent scrolling
          touchMoveX = e.touches[0].clientX;
          touchMoveY = e.touches[0].clientY;

          const diffX = touchMoveX - touchStartX;
          const diffY = touchMoveY - touchStartY;
          const threshold = boardElement.clientWidth / BOARD_WIDTH;

          // Horizontal movement
          if (Math.abs(diffX) > threshold) {
            movePiece(diffX > 0 ? 1 : -1, 0);
            touchStartX = touchMoveX; // Reset start position
            isTouchMoving = true;
            draw();
          }

          // Vertical movement (Swipe Down to Drop)
          // Require a more significant swipe for drop to avoid accidental drops while moving sideways
          if (
            diffY > threshold * 2 &&
            Math.abs(diffY) > Math.abs(diffX) * 1.5
          ) {
            dropPiece();
            touchStartY = touchMoveY; // Reset to prevent multiple drops in one swipe if not desired, or let it flow
            isTouchMoving = true;
          }
        },
        { passive: false }
      );

      gameAreaElement.addEventListener("touchend", (e) => {
        if (!isTouchMoving) {
          // It was a tap
          cycleLetter();
        }
      });

      /**
       * Utility to animate button scale on click.
       * @param {HTMLElement} el
       * @param {Function} callback
       */
      function animateButton(el, callback) {
        // Trigger haptic feedback for PWA
        if (navigator.vibrate) {
          navigator.vibrate(10);
        }

        gsap.to(el, {
          scale: 0.9,
          duration: 0.1,
          yoyo: true,
          repeat: 1,
          ease: "power1.inOut",
          onComplete: () => {
            if (callback) callback();
          },
        });
      }

      startButton.addEventListener("click", () =>
        animateButton(startButton, startGame)
      );
      document.getElementById("A-button").addEventListener("click", () => {
        animateButton(document.getElementById("A-button"), () => {
          if (!startScreen.classList.contains("hidden")) {
            startGame();
          } else if (!gameOverScreen.classList.contains("hidden")) {
            quitGame();
          } else {
            cycleLetter(1);
          }
        });
      });

      document.getElementById("B-button").addEventListener("click", () => {
        animateButton(document.getElementById("B-button"), () => {
          if (wordsSheet.classList.contains("show")) {
            wordsSheet.classList.remove("show");
          } else if (optionsSheet.classList.contains("show")) {
            optionsSheet.classList.remove("show");
          } else if (isPaused) {
            togglePause();
          } else {
            cycleLetter(-1);
          }
        });
      });
      document.getElementById("left-button").addEventListener("click", () => {
        animateButton(document.getElementById("left-button"), () => {
          movePiece(-1, 0);
          draw();
        });
      });
      document.getElementById("right-button").addEventListener("click", () => {
        animateButton(document.getElementById("right-button"), () => {
          movePiece(1, 0);
          draw();
        });
      });
      document.getElementById("down-button").addEventListener("click", () => {
        animateButton(document.getElementById("down-button"), hardDrop);
      });
      document.getElementById("select-button").addEventListener("click", () => {
        animateButton(document.getElementById("select-button"), () => {
          if (!startScreen.classList.contains("hidden")) {
            startGame();
          } else if (!gameOverScreen.classList.contains("hidden")) {
            quitGame();
          } else {
            togglePause();
          }
        });
      });


      // Pause Screen Buttons
      document.getElementById("pause-words-button").addEventListener("click", () => {
        animateButton(document.getElementById("pause-words-button"), () => {
          wordsSheet.classList.add("show");
          gsap.fromTo(
            "#found-words-list li",
            { x: -20, opacity: 0 },
            {
              x: 0,
              opacity: 1,
              duration: 0.4,
              stagger: 0.05,
              ease: "power2.out",
            }
          );
        });
      });

      document.getElementById("pause-options-button").addEventListener("click", () => {
        animateButton(document.getElementById("pause-options-button"), () => {
          optionsSheet.classList.add("show");
        });
      });

      // Speed Slider Listener
      speedSlider.addEventListener("input", (e) => {
        INITIAL_DROP_SPEED = parseInt(e.target.value);
        updateDropSpeed();
      });



      restartButton.addEventListener("click", () =>
        animateButton(restartButton, quitGame)
      );
      resumeButton.addEventListener("click", () =>
        animateButton(resumeButton, togglePause)
      );
      quitButton.addEventListener("click", () =>
        animateButton(quitButton, quitGame)
      );


      closeWordsButton.addEventListener("click", () =>
        wordsSheet.classList.remove("show")
      );

      closeOptionsButton.addEventListener("click", () =>
        optionsSheet.classList.remove("show")
      );


      // Register Service Worker
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("sw.js")
            .then((reg) => {
              console.log("SW registered!", reg);
              // Check for updates
              reg.onupdatefound = () => {
                const installingWorker = reg.installing;
                installingWorker.onstatechange = () => {
                  if (installingWorker.state === "installed") {
                    if (navigator.serviceWorker.controller) {
                      console.log("New content available; please refresh.");
                    }
                  }
                };
              };
            })
            .catch((err) => {
              console.log("SW registration failed:", err);
            });
        });
      }
    </script>
  </body>
</html>
